/**
 * PET Clone - Open hardware implementation of the Commodore PET
 * by Daniel Lehenbauer and contributors.
 * 
 * https://github.com/DLehenbauer/commodore-pet-clone
 *
 * To the extent possible under law, I, Daniel Lehenbauer, have waived all
 * copyright and related or neighboring rights to this project. This work is
 * published from the United States.
 *
 * @copyright CC0 http://creativecommons.org/publicdomain/zero/1.0/
 * @author Daniel Lehenbauer <DLehenbauer@users.noreply.github.com> and contributors
 */

#include "tmds_encode.h"

// Palette table: Pre-computed intensity indices for TMDS lookup
// 
// This table accelerates the two-stage TMDS encoding process:
// 1. Color byte → palette_table → 6-bit intensity index (3-bit bg + 3-bit fg per lane)
// 2. (6-bit index << 7) | (4-bit font pattern << 3) → TMDS LUT → encoded symbols
//
// Structure: 16 fg intensities × 16 bg intensities × 3 lanes
// - Index: color byte with hi nibble = bg palette index (0-15), lo nibble = fg palette index (0-15)
// - Value: (bg_3bit << 3) | fg_3bit, providing bits [9:4] of the 10-bit TMDS LUT address
// - Layout: [B, G, R] for each color combination (matches DVI lane order)
uint8_t __scratch_x("palette_table") __aligned(4) palette_table[16 * 16 * N_TMDS_LANES];

// TMDS lookup table: Pre-encoded DVI symbols for 4-bit pixel patterns
//
// This table provides the final stage of TMDS encoding, mapping intensity combinations
// and pixel patterns directly to DC-balanced DVI symbols.
//
// Structure: 8 bg × 8 fg intensities × 16 pixel patterns × 2 words = 2048 entries
// - Index: 10-bit address = (6-bit intensity index << 7) | (4-bit pixel pattern << 3)
//   - Bits [9:7]: background intensity (0-7, 3-bit)
//   - Bits [6:4]: foreground intensity (0-7, 3-bit)
//   - Bits [3:0]: pixel pattern (nibble from font bitmap)
// - Value: Two 32-bit words containing four packed 10-bit TMDS symbols
//   - Word 0: symbols for pixels 0-1
//   - Word 1: symbols for pixels 2-3
//
// The table is generated by generate_tmds_table.py using DC-balanced encoding pairs
// that maintain zero cumulative disparity across even/odd pixel positions.
//
// Generated by: python3 generate_tmds_table.py 8
#include "tmds_table.h"

// ============================================================================
// Palette Functions
// ============================================================================

void set_palette(const uint8_t* fg_palette, const uint8_t* bg_palette) {
    // The palettes contain RGB332 values (R:3, G:3, B:2).  However, we use the
    // same 3-bit TMDS LUT for all three lanes, so we need to map the 2-bit blue
    // values to 3-bit values.
    static const uint8_t blue_2to3[4] = {0, 2, 5, 7};

    for (int bg = 0; bg < 16; bg++) {
        for (int fg = 0; fg < 16; fg++) {
            uint8_t color_byte = (bg << 4) | fg;
            uint8_t bg_rgb332 = bg_palette[bg];
            uint8_t fg_rgb332 = fg_palette[fg];

            // Extract R, G, B values from RGB332 format
            // RGB332: bits 7:5 = R (3-bit), bits 4:2 = G (3-bit), bits 1:0 = B (2-bit)
            uint8_t bg_r3 = (bg_rgb332 >> 5) & 0x07;
            uint8_t bg_g3 = (bg_rgb332 >> 2) & 0x07;
            uint8_t bg_b3 = blue_2to3[bg_rgb332 & 0x03]; // Map 2-bit to 3-bit

            uint8_t fg_r3 = (fg_rgb332 >> 5) & 0x07;
            uint8_t fg_g3 = (fg_rgb332 >> 2) & 0x07;
            uint8_t fg_b3 = blue_2to3[fg_rgb332 & 0x03]; // Map 2-bit to 3-bit

            // Pack 3-bit values as (bg_3bit << 3) | fg_3bit for each channel.
            // This creates a 6-bit value that indexes into the TMDS LUT.
            // The LUT is organized with bg in bits 5:3 and fg in bits 2:0.
            palette_table[color_byte * 3 + 0] = (bg_b3 << 3) | fg_b3; // B plane (TMDS lane 0)
            palette_table[color_byte * 3 + 1] = (bg_g3 << 3) | fg_g3; // G plane (TMDS lane 1)
            palette_table[color_byte * 3 + 2] = (bg_r3 << 3) | fg_r3; // R plane (TMDS lane 2)
        }
    }
}
